// src/index.ts
import {bech32} from "bech32";
var _AddressV1 = class {
  static prefix() {
    return this.PREFIX;
  }
  constructor(payload) {
    this.payload = payload;
  }
  string() {
    const grouped = bech32.toWords(this.payload);
    return bech32.encode(_AddressV1.prefix(), grouped);
  }
  stringEth() {
    return `0x${Buffer.from(this.payload).toString("hex")}`;
  }
  bytes() {
    return this.payload;
  }
};
var AddressV1 = _AddressV1;
AddressV1.ADDRESS_LENGTH = 20;
AddressV1.PREFIX = "io";
function fromEthereum(addrStr) {
  if (addrStr.startsWith("0x")) {
    addrStr = addrStr.substring(2);
  }
  const bytes = Buffer.from(addrStr, "hex");
  return fromBytes(bytes);
}
function fromBytes(bytes) {
  if (bytes.length !== AddressV1.ADDRESS_LENGTH) {
    throw new Error(`invalid address length in bytes: ${bytes.length}`);
  }
  const addr = new AddressV1(bytes);
  return addr;
}
function fromString(addrStr) {
  const {prefix, words} = bech32.decode(addrStr);
  if (prefix !== AddressV1.prefix()) {
    throw new Error(`hrp ${prefix} and address prefix ${AddressV1.prefix()} don't match`);
  }
  const addr = new AddressV1(bech32.fromWords(words));
  return addr;
}
function from(addr) {
  if (addr.startsWith(AddressV1.PREFIX)) {
    return fromString(addr);
  }
  if (addr.startsWith("0x")) {
    return fromEthereum(addr);
  }
  throw new Error("unknow address format");
}
export {
  from,
  fromBytes,
  fromEthereum,
  fromString
};
